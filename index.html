<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªçc ti·∫øng Nga c√πng Th·∫£o Nguy√™n</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* N·ªÅn m√†u x√°m nh·∫°t */
        }
        .container {
            max-width: 800px;
        }
        textarea {
            resize: vertical; /* Cho ph√©p thay ƒë·ªïi k√≠ch th∆∞·ªõc theo chi·ªÅu d·ªçc */
            min-height: 150px; /* Chi·ªÅu cao t·ªëi thi·ªÉu cho textarea */
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #4f46e5; /* Tailwind indigo-600 */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .clickable-word {
            cursor: pointer;
            @apply text-indigo-700 font-medium hover:underline;
        }
        .definition-item {
            margin-bottom: 0.5rem; /* Kho·∫£ng c√°ch gi·ªØa c√°c m·ª•c ƒë·ªãnh nghƒ©a */
        }
        /* Style for stressed Russian text - no red color, just the accent */
        .stressed-russian-text {
            font-size: 1.125rem; /* text-lg */
            font-weight: 500; /* font-medium */
            color: #1a202c; /* gray-900 */
            white-space: pre-wrap;
            word-break: break-words;
            margin-top: 0.5rem;
            padding: 0.75rem;
            background-color: #e2e8f0; /* gray-200 */
            border-radius: 0.375rem; /* rounded-md */
        }
        /* Adjusted slider styling for better alignment */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db; /* gray-300 */
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 4px;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5; /* indigo-600 */
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3); /* focus ring effect */
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5; /* indigo-600 */
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3); /* focus ring effect */
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div class="container bg-white p-8 rounded-lg shadow-xl w-full">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">H·ªçc ti·∫øng Nga c√πng Th·∫£o Nguy√™n</h1>

        <div class="mb-6">
            <label for="russianInput" class="block text-gray-700 text-sm font-medium mb-2">Nh·∫≠p vƒÉn b·∫£n ti·∫øng Nga:</label>
            <textarea id="russianInput"
                      class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-200"
                      placeholder="–í–≤–µ–¥–∏—Ç–µ —Ä—É—Å—Å–∫–∏–π —Ç–µ–∫—Å—Ç –∑–¥–µ—Å—å... –ù–∞–ø—Ä–∏–º–µ—Ä: –ü—Ä–∏–≤–µ—Ç, –§–∞–º! –¢–µ–±–µ –≤—Å–µ–≥–æ —Å–∞–º–æ–≥–æ –Ω–∞–∏–ª—É—á—à–µ–≥–æ!üçÄ"
                      rows="6"></textarea>
        </div>

        <div class="flex flex-col sm:flex-row gap-4 mb-6">
            <button id="convertButton"
                    class="w-full sm:w-1/2 bg-indigo-600 text-white py-3 px-4 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition duration-200 flex items-center justify-center">
                <span id="buttonText">D·ªãch & Tra t·ª´</span>
                <div id="loadingSpinner" class="loading-spinner ml-3 hidden"></div>
            </button>
            <button id="grammarCheckButton"
                    class="w-full sm:w-1/2 bg-purple-600 text-white py-3 px-4 rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition duration-200 flex items-center justify-center">
                <span id="grammarButtonText">‚ú® Ki·ªÉm tra ng·ªØ ph√°p & C·∫£i thi·ªán c√¢u</span>
                <div id="grammarLoadingSpinner" class="loading-spinner ml-3 hidden"></div>
            </button>
        </div>

        <div id="errorMessage" class="text-red-600 mt-4 hidden text-center"></div>

        <!-- Grammar Check Output Section -->
        <div id="grammarOutputContainer" class="mt-8 p-6 bg-gray-50 border border-gray-200 rounded-md hidden">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">C√¢u ti·∫øng Nga ƒë√£ s·ª≠a/c·∫£i thi·ªán:</h2>
            <p id="correctedSentenceOutput" class="text-gray-900 text-lg whitespace-pre-wrap break-words">
                <!-- Corrected sentence will be displayed here -->
            </p>
            <div id="grammarErrorMessage" class="text-red-600 mt-2 hidden"></div>
        </div>

        <!-- Russian Pronunciation Section -->
        <div id="russianPronunciationContainer" class="mt-8 p-6 bg-gray-50 border border-gray-200 rounded-md">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">Ph√°t √¢m ti·∫øng Nga:</h2>
            <p id="stressedRussianOutput" class="stressed-russian-text hidden">
                <!-- Stressed Russian text will be displayed here -->
            </p>
            <div class="flex flex-col sm:flex-row items-center justify-between mt-4 gap-4">
                <button id="speakButton"
                        class="w-full sm:w-auto bg-green-600 text-white py-2 px-4 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition duration-200 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM14.657 2.929a1 1 0 011.414 0A9.997 9.997 0 0119 10a9.997 9.997 0 01-2.929 7.071 1 1 0 01-1.414-1.414A7.997 7.997 0 0017 10a7.997 7.997 0 00-2.343-5.657 1 1 0 010-1.414zm-2.828 2.828a1 1 0 011.414 0A3.998 3.998 0 0115 10a3.998 3.998 0 01-1.172 2.828 1 1 0 01-1.414-1.414A1.998 1.998 0 0013 10a1.998 1.998 0 00-.586-1.414 1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                    <span id="speakButtonText">Ph√°t √¢m</span>
                </button>
                <div class="flex items-center gap-2 w-full sm:w-auto">
                    <label for="voiceSelect" class="text-gray-700 text-sm font-medium">Gi·ªçng ƒë·ªçc:</label>
                    <select id="voiceSelect" class="p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-200 w-full sm:w-auto">
                        <!-- Gi·ªçng ƒë·ªçc s·∫Ω ƒë∆∞·ª£c t·∫£i b·ªüi JavaScript -->
                    </select>
                </div>
                <div class="flex items-center gap-2 w-full sm:w-auto">
                    <label for="rateSlider" class="text-gray-700 text-sm font-medium">T·ªëc ƒë·ªô:</label>
                    <input type="range" id="rateSlider" min="0.5" max="2" value="1" step="0.1" class="w-full sm:w-auto">
                    <span id="rateValue" class="text-gray-700 text-sm font-medium">1.0x</span>
                </div>
            </div>
        </div>

        <!-- Vietnamese Translation Section -->
        <div id="translationOutputContainer" class="mt-8 p-6 bg-gray-50 border border-gray-200 rounded-md">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">D·ªãch nghƒ©a ti·∫øng Vi·ªát:</h2>
            <p id="vietnameseTranslation" class="text-gray-900 text-lg whitespace-pre-wrap break-words">
                <!-- B·∫£n d·ªãch ti·∫øng Vi·ªát s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y -->
            </p>
        </div>

        <!-- Dictionary Section -->
        <div id="dictionarySection" class="mt-8 p-6 bg-gray-50 border border-gray-200 rounded-md">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">Tra t·ª´ ƒëi·ªÉn ti·∫øng Nga (vtudien.com):</h2>
            <p class="text-gray-700 text-sm mb-3">Nh·∫•p v√†o m·ªôt t·ª´ ti·∫øng Nga d∆∞·ªõi ƒë√¢y ƒë·ªÉ tra c·ª©u nghƒ©a:</p>
            <div id="clickableWordsContainer" class="flex flex-wrap gap-x-2 gap-y-1 mb-4">
                <!-- C√°c t·ª´ c√≥ th·ªÉ nh·∫•p s·∫Ω ƒë∆∞·ª£c ch√®n v√†o ƒë√¢y -->
            </div>
            <div id="wordDefinitionOutput" class="p-4 bg-white border border-gray-300 rounded-md hidden">
                <h3 class="text-lg font-semibold text-gray-800 mb-2" id="definedWord"></h3>
                <div id="definitionContent" class="text-gray-900">
                    <!-- Chi ti·∫øt ƒë·ªãnh nghƒ©a s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y -->
                </div>
                <div id="definitionLoadingSpinner" class="loading-spinner mt-2 hidden"></div>
                <div id="definitionErrorMessage" class="text-red-600 mt-2 hidden"></div>
            </div>
        </div>

        <!-- Wiki Dictionary Section -->
        <div id="wikiDictionarySection" class="mt-8 p-6 bg-gray-50 border border-gray-200 rounded-md">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">Tra Wiki ti·∫øng Nga (ru.wiktionary.org):</h2>
            <p class="text-gray-700 text-sm mb-3">Nh·∫•p v√†o m·ªôt t·ª´ ti·∫øng Nga d∆∞·ªõi ƒë√¢y ƒë·ªÉ tra c·ª©u tr√™n Wiktionary:</p>
            <div id="clickableWordsContainerWiki" class="flex flex-wrap gap-x-2 gap-y-1 mb-4">
                <!-- C√°c t·ª´ c√≥ th·ªÉ nh·∫•p s·∫Ω ƒë∆∞·ª£c ch√®n v√†o ƒë√¢y -->
            </div>
            <div id="wikiDefinitionOutput" class="p-4 bg-white border border-gray-300 rounded-md hidden">
                <h3 class="text-lg font-semibold text-gray-800 mb-2" id="definedWikiWord"></h3>
                <div id="wikiDefinitionContent" class="text-gray-900">
                    <!-- Chi ti·∫øt ƒë·ªãnh nghƒ©a Wiki s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y -->
                </div>
                <div id="wikiDefinitionLoadingSpinner" class="loading-spinner mt-2 hidden"></div>
                <div id="wikiDefinitionErrorMessage" class="text-red-600 mt-2 hidden"></div>
            </div>
        </div>

        <!-- YouGlish Section -->
        <div id="youglishSection" class="mt-8 p-6 bg-gray-50 border border-gray-200 rounded-md">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">Tra YouGlish ti·∫øng Nga (youglish.com):</h2>
            <p class="text-gray-700 text-sm mb-3">Nh·∫•p v√†o m·ªôt t·ª´ ti·∫øng Nga d∆∞·ªõi ƒë√¢y ƒë·ªÉ xem video ph√°t √¢m tr√™n YouGlish:</p>
            <div id="clickableWordsContainerYouglish" class="flex flex-wrap gap-x-2 gap-y-1 mb-4">
                <!-- C√°c t·ª´ c√≥ th·ªÉ nh·∫•p s·∫Ω ƒë∆∞·ª£c ch√®n v√†o ƒë√¢y -->
            </div>
            <div id="youglishOutput" class="p-4 bg-white border border-gray-300 rounded-md hidden">
                <h3 class="text-lg font-semibold text-gray-800 mb-2" id="definedYouglishWord"></h3>
                <div id="youglishContent" class="text-gray-900">
                    <!-- Chi ti·∫øt YouGlish s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y -->
                </div>
                <div id="youglishLoadingSpinner" class="loading-spinner mt-2 hidden"></div>
                <div id="youglishErrorMessage" class="text-red-600 mt-2 hidden"></div>
            </div>
        </div>

        <!-- Vocabulary Builder Section -->
        <div id="vocabularyBuilderSection" class="mt-8 p-6 bg-gray-50 border border-gray-200 rounded-md">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">‚ú® T·∫°o t·ª´ v·ª±ng theo ch·ªß ƒë·ªÅ:</h2>
            <div class="flex flex-col sm:flex-row gap-4 mb-4">
                <input type="text" id="topicInput"
                       class="flex-grow p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-200"
                       placeholder="Nh·∫≠p ch·ªß ƒë·ªÅ (v√≠ d·ª•: du l·ªãch, ƒë·ªì ƒÉn)">
                <button id="generateVocabularyButton"
                        class="bg-blue-600 text-white py-3 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-200 flex items-center justify-center">
                    <span id="vocabularyButtonText">T·∫°o t·ª´ v·ª±ng</span>
                    <div id="vocabularyLoadingSpinner" class="loading-spinner ml-3 hidden"></div>
                </button>
            </div>
            <div id="vocabularyOutput" class="p-4 bg-white border border-gray-300 rounded-md hidden">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">T·ª´ v·ª±ng ƒë√£ t·∫°o:</h3>
                <ul id="vocabularyList" class="list-disc pl-5 text-gray-900">
                    <!-- Vocabulary list will be displayed here -->
                </ul>
                <div id="vocabularyErrorMessage" class="text-red-600 mt-2 hidden"></div>
            </div>
        </div>

        <!-- Sentence Builder Section -->
        <div id="sentenceBuilderSection" class="mt-8 p-6 bg-gray-50 border border-gray-200 rounded-md">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">‚ú® T·∫°o c√¢u m·∫´u theo ch·ªß ƒë·ªÅ t·ª´ v·ª±ng:</h2>
            <div class="flex flex-col sm:flex-row gap-4 mb-4">
                <input type="text" id="sentenceTopicInput"
                       class="flex-grow p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-200"
                       placeholder="Nh·∫≠p ch·ªß ƒë·ªÅ c√¢u (v√≠ d·ª•: ch√†o h·ªèi, mua s·∫Øm)">
                <button id="generateSentenceButton"
                        class="bg-blue-600 text-white py-3 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-200 flex items-center justify-center">
                    <span id="sentenceButtonText">T·∫°o c√¢u m·∫´u</span>
                    <div id="sentenceLoadingSpinner" class="loading-spinner ml-3 hidden"></div>
                </button>
            </div>
            <div id="sentenceOutput" class="p-4 bg-white border border-gray-300 rounded-md hidden">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">C√¢u m·∫´u ƒë√£ t·∫°o:</h3>
                <ul id="sentenceList" class="list-disc pl-5 text-gray-900">
                    <!-- Sentence list will be displayed here -->
                </ul>
                <div id="sentenceErrorMessage" class="text-red-600 mt-2 hidden"></div>
            </div>
        </div>

        <!-- Russian Learning Resources Section -->
        <div id="resourcesSection" class="mt-8 p-6 bg-gray-50 border border-gray-200 rounded-md">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">T√†i nguy√™n h·ªçc ti·∫øng Nga:</h2>
            <ul class="list-disc pl-5 text-gray-900">
                <li class="mb-2">
                    <a href="https://russiangram.com/" target="_blank" class="text-blue-600 hover:underline">RussianGram.com</a> - Ng·ªØ ph√°p ti·∫øng Nga d·ªÖ hi·ªÉu.
                </li>
                <li class="mb-2">
                    <a href="https://www.duolingo.com/course/ru/en/Learn-Russian" target="_blank" class="text-blue-600 hover:underline">Duolingo (Ti·∫øng Nga)</a> - H·ªçc ti·∫øng Nga m·ªôt c√°ch vui v·∫ª.
                </li>
                <li class="mb-2">
                    <a href="https://www.memrise.com/learn-russian/" target="_blank" class="text-blue-600 hover:underline">Memrise (Ti·∫øng Nga)</a> - H·ªçc t·ª´ v·ª±ng v√† c·ª•m t·ª´ ti·∫øng Nga.
                </li>
                <li class="mb-2">
                    <a href="https://www.youtube.com/c/RussianPod101" target="_blank" class="text-blue-600 hover:underline">RussianPod101 (YouTube)</a> - C√°c b√†i h·ªçc video ti·∫øng Nga.
                </li>
            </ul>
        </div>

    </div>

    <script type="module">
        // L·∫•y tham chi·∫øu ƒë·∫øn c√°c ph·∫ßn t·ª≠ DOM
        const russianInput = document.getElementById('russianInput');
        const convertButton = document.getElementById('convertButton');
        const buttonText = document.getElementById('buttonText');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const grammarCheckButton = document.getElementById('grammarCheckButton');
        const grammarButtonText = document.getElementById('grammarButtonText');
        const grammarLoadingSpinner = document.getElementById('grammarLoadingSpinner');
        const grammarOutputContainer = document.getElementById('grammarOutputContainer');
        const correctedSentenceOutput = document.getElementById('correctedSentenceOutput');
        const grammarErrorMessage = document.getElementById('grammarErrorMessage');

        const speakButton = document.getElementById('speakButton');
        const speakButtonText = document.getElementById('speakButtonText');
        const voiceSelect = document.getElementById('voiceSelect');
        const rateSlider = document.getElementById('rateSlider');
        const rateValueSpan = document.getElementById('rateValue');
        const stressedRussianOutput = document.getElementById('stressedRussianOutput');
        const vietnameseTranslation = document.getElementById('vietnameseTranslation');
        const clickableWordsContainer = document.getElementById('clickableWordsContainer'); // For vtudien.com
        const wordDefinitionOutput = document.getElementById('wordDefinitionOutput');
        const definedWord = document.getElementById('definedWord');
        const definitionContent = document.getElementById('definitionContent');
        const definitionLoadingSpinner = document.getElementById('definitionLoadingSpinner');
        const definitionErrorMessage = document.getElementById('definitionErrorMessage');
        const errorMessage = document.getElementById('errorMessage');

        const wikiDictionarySection = document.getElementById('wikiDictionarySection');
        const clickableWordsContainerWiki = document.getElementById('clickableWordsContainerWiki'); // For Wiktionary
        const wikiDefinitionOutput = document.getElementById('wikiDefinitionOutput');
        const definedWikiWord = document.getElementById('definedWikiWord');
        const wikiDefinitionContent = document.getElementById('wikiDefinitionContent');
        const wikiDefinitionLoadingSpinner = document.getElementById('wikiDefinitionLoadingSpinner');
        const wikiDefinitionErrorMessage = document.getElementById('wikiDefinitionErrorMessage');

        const youglishSection = document.getElementById('youglishSection');
        const clickableWordsContainerYouglish = document.getElementById('clickableWordsContainerYouglish'); // For YouGlish
        const youglishOutput = document.getElementById('youglishOutput');
        const definedYouglishWord = document.getElementById('definedYouglishWord');
        const youglishContent = document.getElementById('youglishContent');
        const youglishLoadingSpinner = document.getElementById('youglishLoadingSpinner');
        const youglishErrorMessage = document.getElementById('youglishErrorMessage');


        const topicInput = document.getElementById('topicInput');
        const generateVocabularyButton = document.getElementById('generateVocabularyButton');
        const vocabularyButtonText = document.getElementById('vocabularyButtonText');
        const vocabularyLoadingSpinner = document.getElementById('vocabularyLoadingSpinner');
        const vocabularyOutput = document.getElementById('vocabularyOutput');
        const vocabularyList = document.getElementById('vocabularyList');
        const vocabularyErrorMessage = document.getElementById('vocabularyErrorMessage');

        const sentenceTopicInput = document.getElementById('sentenceTopicInput');
        const generateSentenceButton = document.getElementById('generateSentenceButton');
        const sentenceButtonText = document.getElementById('sentenceButtonText');
        const sentenceLoadingSpinner = document.getElementById('sentenceLoadingSpinner');
        const sentenceOutput = document.getElementById('sentenceOutput');
        const sentenceList = document.getElementById('sentenceList');
        const sentenceErrorMessage = document.getElementById('sentenceErrorMessage');


        let selectedVoice = null; // Bi·∫øn l∆∞u tr·ªØ gi·ªçng ƒë·ªçc ƒë√£ ch·ªçn
        let isSpeaking = false; // Bi·∫øn theo d√µi tr·∫°ng th√°i ph√°t √¢m
        let currentUtterance = null; // Bi·∫øn l∆∞u tr·ªØ ƒë·ªëi t∆∞·ª£ng SpeechSynthesisUtterance hi·ªán t·∫°i

        /**
         * X√≥a t·∫•t c·∫£ c√°c ƒë·∫ßu ra v√† th√¥ng b√°o l·ªói.
         */
        function clearOutputs() {
            stressedRussianOutput.textContent = '';
            stressedRussianOutput.classList.add('hidden');
            vietnameseTranslation.textContent = '';
            clickableWordsContainer.innerHTML = '';
            clickableWordsContainerWiki.innerHTML = ''; // Clear wiki clickable words too
            clickableWordsContainerYouglish.innerHTML = ''; // Clear YouGlish clickable words too
            wordDefinitionOutput.classList.add('hidden');
            definedWord.textContent = '';
            definitionContent.innerHTML = '';
            wikiDefinitionOutput.classList.add('hidden'); // Clear wiki output
            definedWikiWord.textContent = '';
            wikiDefinitionContent.innerHTML = '';
            youglishOutput.classList.add('hidden'); // Clear YouGlish output
            definedYouglishWord.textContent = '';
            youglishContent.innerHTML = '';
            errorMessage.textContent = '';
            errorMessage.classList.add('hidden');
            definitionErrorMessage.textContent = '';
            definitionErrorMessage.classList.add('hidden');
            wikiDefinitionErrorMessage.textContent = ''; // Clear wiki error
            wikiDefinitionErrorMessage.classList.add('hidden');
            youglishErrorMessage.textContent = ''; // Clear YouGlish error
            youglishErrorMessage.classList.add('hidden');
            grammarOutputContainer.classList.add('hidden');
            correctedSentenceOutput.textContent = '';
            grammarErrorMessage.classList.add('hidden');
            grammarErrorMessage.textContent = '';
            vocabularyOutput.classList.add('hidden');
            vocabularyList.innerHTML = '';
            vocabularyErrorMessage.classList.add('hidden');
            vocabularyErrorMessage.textContent = '';
            sentenceOutput.classList.add('hidden'); // Clear sentence output
            sentenceList.innerHTML = '';
            sentenceErrorMessage.classList.add('hidden');
            sentenceErrorMessage.textContent = '';
            // D·ª´ng m·ªçi ph√°t √¢m ƒëang di·ªÖn ra khi x√≥a ƒë·∫ßu ra
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }
            isSpeaking = false;
            speakButtonText.textContent = 'Ph√°t √¢m';
        }

        /**
         * Th·ª±c hi·ªán cu·ªôc g·ªçi API ƒë·∫øn m√¥ h√¨nh Gemini.
         * @param {string} prompt L·ªùi nh·∫Øc g·ª≠i ƒë·∫øn m√¥ h√¨nh.
         * @param {Object} [generationConfig] C·∫•u h√¨nh t·∫°o t√πy ch·ªçn cho ƒë·∫ßu ra c√≥ c·∫•u tr√∫c.
         * @returns {Promise<string|Object>} Ph·∫£n h·ªìi vƒÉn b·∫£n ho·∫∑c ƒë·ªëi t∆∞·ª£ng JSON ƒë√£ ph√¢n t√≠ch c√∫ ph√°p t·ª´ m√¥ h√¨nh.
         */
        async function callGeminiAPI(prompt, generationConfig = {}) {
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });

            const payload = { contents: chatHistory, generationConfig };
            const apiKey = "AIzaSyByK7ww7MRpFmUHJU7Mz70qj6OhjUFYMCg"; // Kh√≥a API ƒë∆∞·ª£c cung c·∫•p t·ª± ƒë·ªông b·ªüi m√¥i tr∆∞·ªùng Canvas
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorDetail = await response.json();
                throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorDetail.error.message || 'Unknown error'}`);
            }

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                const responseText = result.candidates[0].content.parts[0].text;
                if (generationConfig.responseMimeType === "application/json") {
                    try {
                        return JSON.parse(responseText);
                    } catch (e) {
                        console.error("JSON parsing error:", e, "Raw response from API:", responseText); // Added raw response log
                        throw new Error("Invalid JSON response from API.");
                    }
                }
                return responseText;
            } else {
                throw new Error('Unexpected API response structure or missing content.');
            }
        }

        /**
         * X·ª≠ l√Ω vi·ªác d·ªãch vƒÉn b·∫£n ti·∫øng Nga sang ti·∫øng Vi·ªát v√† thi·∫øt l·∫≠p tra c·ª©u t·ª´.
         */
        convertButton.addEventListener('click', async () => {
            const text = russianInput.value.trim();
            clearOutputs(); // Clear all previous outputs

            if (!text) {
                errorMessage.textContent = 'Vui l√≤ng nh·∫≠p vƒÉn b·∫£n ti·∫øng Nga ƒë·ªÉ d·ªãch.';
                errorMessage.classList.remove('hidden');
                return;
            }

            // Hi·ªÉn th·ªã tr·∫°ng th√°i t·∫£i cho n√∫t ch√≠nh
            buttonText.textContent = 'ƒêang x·ª≠ l√Ω...';
            loadingSpinner.classList.remove('hidden');
            convertButton.disabled = true;
            convertButton.classList.add('opacity-70', 'cursor-not-allowed');

            try {
                // --- 1. D·ªãch ti·∫øng Nga sang ti·∫øng Vi·ªát ---
                const translationPrompt = `Translate the following Russian text into Vietnamese. Provide only the translation, no additional text or explanations.
                
                Text: "${text}"`;
                const vietTranslation = await callGeminiAPI(translationPrompt);
                vietnameseTranslation.textContent = vietTranslation;

                // --- 2. L·∫•y vƒÉn b·∫£n ti·∫øng Nga c√≥ tr·ªçng √¢m ---
                const stressedRussianPrompt = `Provide the following Russian text with stress marks (—É–¥–∞—Ä–µ–Ω–∏–µ). Ensure the stressed vowel is marked with &#x0301; (combining acute accent). Do not make the text all caps. Only provide the text with stress marks, no other explanations or formatting.
                
                Text: "${text}"`;
                const stressedTextRaw = await callGeminiAPI(stressedRussianPrompt);
                
                // Assign raw stressed text directly. The &#x0301; character should render correctly above the vowel.
                stressedRussianOutput.textContent = stressedTextRaw;
                stressedRussianOutput.classList.remove('hidden');


                // --- 3. Thi·∫øt l·∫≠p c√°c t·ª´ c√≥ th·ªÉ nh·∫•p ƒë·ªÉ tra t·ª´ ƒëi·ªÉn (vtudien.com) ---
                // T√°ch t·ª´ theo d·∫•u c√°ch ho·∫∑c d·∫•u c√¢u.
                // Regex: \b[–∞-—è–ê-–Ø—ë–Å]+\b matches Russian words.
                // /[^\p{L}\p{N}]+/u for splitting by non-letter/non-number characters.
                // For simplicity and direct link generation, splitting by non-word characters.
                const words = text.split(/[\s.,!?;:"'()¬´¬ª-]+/).filter(word => word.length > 0);
                clickableWordsContainer.innerHTML = ''; // X√≥a c√°c t·ª´ tr∆∞·ªõc ƒë√≥
                clickableWordsContainerWiki.innerHTML = ''; // X√≥a c√°c t·ª´ Wiki tr∆∞·ªõc ƒë√≥
                clickableWordsContainerYouglish.innerHTML = ''; // X√≥a c√°c t·ª´ YouGlish tr∆∞·ªõc ƒë√≥

                words.forEach(word => {
                    // For vtudien.com
                    const wordSpan = document.createElement('span');
                    wordSpan.textContent = word;
                    wordSpan.classList.add('clickable-word', 'py-1', 'px-2', 'rounded-md', 'bg-gray-100', 'hover:bg-gray-200', 'transition', 'duration-150');
                    wordSpan.addEventListener('click', () => lookupVtudien(word));
                    clickableWordsContainer.appendChild(wordSpan);

                    // For ru.wiktionary.org
                    const wordSpanWiki = document.createElement('span');
                    wordSpanWiki.textContent = word;
                    wordSpanWiki.classList.add('clickable-word', 'py-1', 'px-2', 'rounded-md', 'bg-gray-100', 'hover:bg-gray-200', 'transition', 'duration-150');
                    wordSpanWiki.addEventListener('click', () => lookupWiki(word));
                    clickableWordsContainerWiki.appendChild(wordSpanWiki);

                    // For YouGlish.com
                    const wordSpanYouglish = document.createElement('span');
                    wordSpanYouglish.textContent = word;
                    wordSpanYouglish.classList.add('clickable-word', 'py-1', 'px-2', 'rounded-md', 'bg-gray-100', 'hover:bg-gray-200', 'transition', 'duration-150');
                    wordSpanYouglish.addEventListener('click', () => lookupYouglish(word));
                    clickableWordsContainerYouglish.appendChild(wordSpanYouglish);
                });

            } catch (error) {
                console.error('L·ªói khi x·ª≠ l√Ω:', error);
                errorMessage.textContent = `ƒê√£ x·∫£y ra l·ªói: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.`;
                errorMessage.classList.remove('hidden');
            } finally {
                // ƒê·∫∑t l·∫°i tr·∫°ng th√°i n√∫t
                buttonText.textContent = 'D·ªãch & Tra t·ª´';
                loadingSpinner.classList.add('hidden');
                convertButton.disabled = false;
                convertButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }
        });

        /**
         * X·ª≠ l√Ω ki·ªÉm tra ng·ªØ ph√°p v√† c·∫£i thi·ªán c√¢u ti·∫øng Nga.
         */
        grammarCheckButton.addEventListener('click', async () => {
            const text = russianInput.value.trim();
            correctedSentenceOutput.textContent = '';
            grammarErrorMessage.textContent = '';
            grammarErrorMessage.classList.add('hidden');
            grammarOutputContainer.classList.add('hidden'); // Hide until content is ready

            if (!text) {
                grammarErrorMessage.textContent = 'Vui l√≤ng nh·∫≠p vƒÉn b·∫£n ti·∫øng Nga ƒë·ªÉ ki·ªÉm tra ng·ªØ ph√°p.';
                grammarErrorMessage.classList.remove('hidden');
                grammarOutputContainer.classList.remove('hidden');
                return;
            }

            grammarButtonText.textContent = 'ƒêang ki·ªÉm tra...';
            grammarLoadingSpinner.classList.remove('hidden');
            grammarCheckButton.disabled = true;
            grammarCheckButton.classList.add('opacity-70', 'cursor-not-allowed');

            try {
                const grammarPrompt = `Correct any grammatical errors and improve the naturalness of the following Russian sentence. Provide only the corrected/improved sentence, no explanations. If no changes are needed, return the original sentence.
                Sentence: "${text}"`;
                
                const correctedText = await callGeminiAPI(grammarPrompt);
                correctedSentenceOutput.textContent = correctedText;
                grammarOutputContainer.classList.remove('hidden');

            } catch (error) {
                console.error('L·ªói khi ki·ªÉm tra ng·ªØ ph√°p:', error);
                grammarErrorMessage.textContent = `ƒê√£ x·∫£y ra l·ªói khi ki·ªÉm tra ng·ªØ ph√°p: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.`;
                grammarErrorMessage.classList.remove('hidden');
                grammarOutputContainer.classList.remove('hidden');
            } finally {
                grammarButtonText.textContent = '‚ú® Ki·ªÉm tra ng·ªØ ph√°p & C·∫£i thi·ªán c√¢u';
                grammarLoadingSpinner.classList.add('hidden');
                grammarCheckButton.disabled = false;
                grammarCheckButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }
        });

        /**
         * Kh·ªüi t·∫°o c√°c gi·ªçng ƒë·ªçc cho t·ªïng h·ª£p gi·ªçng n√≥i.
         */
        function populateVoiceList() {
            const voices = window.speechSynthesis.getVoices();
            voiceSelect.innerHTML = ''; // X√≥a c√°c t√πy ch·ªçn hi·ªán c√≥
            let defaultRussianVoiceFound = false;

            voices.forEach(voice => {
                // Ch·ªâ th√™m c√°c gi·ªçng ti·∫øng Nga
                if (voice.lang.startsWith('ru-')) {
                    const option = document.createElement('option');
                    option.textContent = `${voice.name} (${voice.lang})`;
                    if (voice.default) {
                        option.textContent += ' -- M·∫∑c ƒë·ªãnh';
                    }
                    option.setAttribute('data-lang', voice.lang);
                    option.setAttribute('data-name', voice.name);
                    voiceSelect.appendChild(option);

                    // C·ªë g·∫Øng ch·ªçn m·ªôt gi·ªçng ti·∫øng Nga m·∫∑c ƒë·ªãnh
                    if (voice.lang === 'ru-RU' && !defaultRussianVoiceFound) {
                        voiceSelect.value = option.value;
                        selectedVoice = voice;
                        defaultRussianVoiceFound = true;
                    }
                }
            });

            // N·∫øu kh√¥ng t√¨m th·∫•y gi·ªçng ru-RU, ch·ªâ ch·ªçn gi·ªçng ti·∫øng Nga ƒë·∫ßu ti√™n n·∫øu c√≥
            if (!defaultRussianVoiceFound && voiceSelect.options.length > 0) {
                voiceSelect.value = voiceSelect.options[0].value;
                const selectedOption = voiceSelect.options[0];
                const voiceName = selectedOption.getAttribute('data-name');
                selectedVoice = window.speechSynthesis.getVoices().find(voice => voice.name === voiceName);
            } else if (voiceSelect.options.length === 0) {
                // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p kh√¥ng c√≥ gi·ªçng ti·∫øng Nga n√†o
                const option = document.createElement('option');
                option.textContent = 'Kh√¥ng c√≥ gi·ªçng ti·∫øng Nga n√†o kh·∫£ d·ª•ng tr√™n h·ªá th·ªëng c·ªßa b·∫°n.';
                option.disabled = true;
                voiceSelect.appendChild(option);
                speakButton.disabled = true; // V√¥ hi·ªáu h√≥a n√∫t ph√°t √¢m n·∫øu kh√¥ng c√≥ gi·ªçng
                console.warn('Kh√¥ng t√¨m th·∫•y gi·ªçng ti·∫øng Nga n√†o kh·∫£ d·ª•ng. Ch·ª©c nƒÉng ph√°t √¢m s·∫Ω b·ªã v√¥ hi·ªáu h√≥a.'); // Explicit warning
            }
        }

        // T·∫£i gi·ªçng ƒë·ªçc khi ch√∫ng s·∫µn s√†ng
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoiceList;
        } else {
            // D·ª± ph√≤ng cho c√°c tr√¨nh duy·ªát kh√¥ng k√≠ch ho·∫°t onvoiceschanged ngay l·∫≠p t·ª©c
            populateVoiceList();
        }

        // Tr√¨nh nghe s·ª± ki·ªán cho thay ƒë·ªïi l·ª±a ch·ªçn gi·ªçng ƒë·ªçc
        voiceSelect.addEventListener('change', () => {
            const selectedOption = voiceSelect.options[voiceSelect.selectedIndex];
            const voiceName = selectedOption.getAttribute('data-name');
            selectedVoice = window.speechSynthesis.getVoices().find(voice => voice.name === voiceName);
            // T√πy ch·ªânh gi·ªçng ƒë·ªçc ƒë∆∞·ª£c √°p d·ª•ng ngay l·∫≠p t·ª©c
            if (isSpeaking && currentUtterance && !window.speechSynthesis.paused) {
                window.speechSynthesis.cancel(); // H·ªßy b·ªè utterance hi·ªán t·∫°i
                startSpeaking(); // B·∫Øt ƒë·∫ßu l·∫°i v·ªõi gi·ªçng m·ªõi
            }
        });

        // Tr√¨nh nghe s·ª± ki·ªán cho thay ƒë·ªïi thanh tr∆∞·ª£t t·ªëc ƒë·ªô
        rateSlider.addEventListener('input', () => {
            rateValueSpan.textContent = `${rateSlider.value}x`;
            // T·ªëc ƒë·ªô ƒë·ªçc ƒë∆∞·ª£c √°p d·ª•ng ngay l·∫≠p t·ª©c
            if (isSpeaking && currentUtterance && !window.speechSynthesis.paused) {
                window.speechSynthesis.cancel(); // H·ªßy b·ªè utterance hi·ªán t·∫°i
                startSpeaking(); // B·∫Øt ƒë·∫ßu l·∫°i v·ªõi t·ªëc ƒë·ªô m·ªõi
            }
        });

        /**
         * B·∫Øt ƒë·∫ßu ph√°t √¢m vƒÉn b·∫£n ti·∫øng Nga.
         */
        function startSpeaking() {
            const textToSpeak = russianInput.value.trim();
            if (!textToSpeak) {
                errorMessage.textContent = 'Kh√¥ng c√≥ vƒÉn b·∫£n ƒë·ªÉ ph√°t √¢m.';
                errorMessage.classList.remove('hidden');
                isSpeaking = false;
                speakButtonText.textContent = 'Ph√°t √¢m';
                return;
            }

            // N·∫øu ƒëang t·∫°m d·ª´ng, ti·∫øp t·ª•c
            if (window.speechSynthesis.paused && currentUtterance) {
                window.speechSynthesis.resume();
                isSpeaking = true;
                speakButtonText.textContent = 'D·ª´ng ph√°t √¢m';
                return;
            }

            // N·∫øu ƒëang n√≥i ho·∫∑c kh√¥ng c√≥ utterance m·ªõi, t·∫°o utterance m·ªõi
            if (!window.speechSynthesis.speaking || !currentUtterance) {
                currentUtterance = new SpeechSynthesisUtterance(textToSpeak);
                currentUtterance.lang = 'ru-RU'; // ƒê·∫£m b·∫£o ng√¥n ng·ªØ l√† ti·∫øng Nga
                if (selectedVoice) {
                    currentUtterance.voice = selectedVoice;
                }
                currentUtterance.rate = parseFloat(rateSlider.value); // ƒê·∫∑t t·ªëc ƒë·ªô n√≥i

                currentUtterance.onstart = () => {
                    isSpeaking = true;
                    speakButtonText.textContent = 'D·ª´ng ph√°t √¢m';
                    errorMessage.classList.add('hidden'); // Clear error on start
                };
                currentUtterance.onend = () => {
                    isSpeaking = false;
                    speakButtonText.textContent = 'Ph√°t √¢m';
                    currentUtterance = null; // Reset utterance after it ends
                };
                currentUtterance.onerror = (event) => {
                    console.error('SpeechSynthesisUtterance.onerror', event);
                    isSpeaking = false;
                    speakButtonText.textContent = 'Ph√°t √¢m';
                    currentUtterance = null; // Reset utterance on error
                    let errorMsg = 'L·ªói ph√°t √¢m: ';
                    switch (event.error) {
                        case 'network':
                            errorMsg += 'L·ªói m·∫°ng. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi internet c·ªßa b·∫°n.';
                            break;
                        case 'synthesis-failed':
                            errorMsg += 'Qu√° tr√¨nh t·ªïng h·ª£p gi·ªçng n√≥i th·∫•t b·∫°i.';
                            break;
                        case 'synthesis-unavailable':
                            errorMsg += 'D·ªãch v·ª• t·ªïng h·ª£p gi·ªçng n√≥i kh√¥ng kh·∫£ d·ª•ng.';
                            break;
                        case 'language-unsupported':
                            errorMsg += 'Ng√¥n ng·ªØ ti·∫øng Nga kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ b·ªüi gi·ªçng ƒë·ªçc ƒë√£ ch·ªçn ho·∫∑c tr√¨nh duy·ªát c·ªßa b·∫°n.';
                            break;
                        case 'voice-unavailable':
                            errorMsg += 'Gi·ªçng ƒë·ªçc ƒë√£ ch·ªçn kh√¥ng kh·∫£ d·ª•ng.';
                            break;
                        default:
                            errorMsg += `L·ªói kh√¥ng x√°c ƒë·ªãnh: ${event.error}.`;
                    }
                    errorMessage.textContent = errorMsg;
                    errorMessage.classList.remove('hidden');
                };

                window.speechSynthesis.speak(currentUtterance);
            }
        }

        /**
         * X·ª≠ l√Ω ph√°t √¢m vƒÉn b·∫£n ti·∫øng Nga b·∫±ng Web Speech API.
         */
        speakButton.addEventListener('click', () => {
            if (window.speechSynthesis.speaking && !window.speechSynthesis.paused) {
                window.speechSynthesis.pause(); // T·∫°m d·ª´ng ph√°t √¢m
                isSpeaking = false;
                speakButtonText.textContent = 'Ti·∫øp t·ª•c ph√°t √¢m';
            } else if (window.speechSynthesis.paused) {
                window.speechSynthesis.resume(); // Ti·∫øp t·ª•c ph√°t √¢m
                isSpeaking = true;
                speakButtonText.textContent = 'D·ª´ng ph√°t √¢m';
            } else {
                startSpeaking(); // B·∫Øt ƒë·∫ßu ph√°t √¢m m·ªõi
            }
        });

        /**
         * Tra c·ª©u ƒë·ªãnh nghƒ©a c·ªßa m·ªôt t·ª´ ƒë√£ cho b·∫±ng c√°ch m·ªü li√™n k·∫øt ƒë·∫øn vtudien.com.
         * @param {string} word T·ª´ c·∫ßn tra c·ª©u.
         */
        async function lookupVtudien(word) {
            definedWord.textContent = `ƒêang m·ªü t·ª´ ƒëi·ªÉn cho: "${word}"`;
            definitionContent.innerHTML = '';
            definitionErrorMessage.textContent = '';
            definitionErrorMessage.classList.add('hidden');
            wordDefinitionOutput.classList.remove('hidden');
            definitionLoadingSpinner.classList.add('hidden'); // Action is instant, hide spinner

            try {
                // Encode the word for URL to handle special characters correctly
                const encodedWord = encodeURIComponent(word);
                const vtudienUrl = `https://vtudien.com/nga-viet/dictionary/nghia-cua-tu-${encodedWord}`;
                
                let htmlContent = `
                    <p class="definition-item">Nh·∫•p v√†o ƒë√¢y ƒë·ªÉ xem chi ti·∫øt nghƒ©a c·ªßa t·ª´ "${word}" tr√™n:</p>
                    <a href="${vtudienUrl}" target="_blank" class="text-blue-600 hover:underline font-semibold text-lg">vtudien.com/nga-viet</a>
                    <p class="text-sm text-gray-500 mt-2">Trang web s·∫Ω m·ªü trong m·ªôt tab m·ªõi.</p>
                `;
                
                definitionContent.innerHTML = htmlContent;
                window.open(vtudienUrl, '_blank'); // Open the tab immediately

            } catch (error) {
                console.error(`L·ªói khi t·∫°o li√™n k·∫øt tra c·ª©u t·ª´ "${word}" tr√™n vtudien.com:`, error);
                definitionErrorMessage.textContent = `Kh√¥ng th·ªÉ m·ªü li√™n k·∫øt tra c·ª©u cho t·ª´ "${word}" tr√™n vtudien.com: ${error.message}. Vui l√≤ng ki·ªÉm tra c√†i ƒë·∫∑t ch·∫∑n pop-up.`;
                definitionErrorMessage.classList.remove('hidden');
                definedWord.textContent = `L·ªói tra c·ª©u t·ª´ "${word}"`;
                definitionContent.innerHTML = '';
            } finally {
                // No loading spinner to hide here, as it was hidden at the start.
            }
        }

        /**
         * Tra c·ª©u ƒë·ªãnh nghƒ©a c·ªßa m·ªôt t·ª´ ƒë√£ cho b·∫±ng c√°ch m·ªü li√™n k·∫øt ƒë·∫øn ru.wiktionary.org.
         * @param {string} word T·ª´ c·∫ßn tra c·ª©u.
         */
        async function lookupWiki(word) {
            definedWikiWord.textContent = `ƒêang m·ªü Wiki cho: "${word}"`;
            wikiDefinitionContent.innerHTML = '';
            wikiDefinitionErrorMessage.textContent = '';
            wikiDefinitionErrorMessage.classList.add('hidden');
            wikiDefinitionOutput.classList.remove('hidden');
            wikiDefinitionLoadingSpinner.classList.add('hidden'); // Action is instant, hide spinner

            try {
                // Encode the word for URL to handle special characters correctly
                const encodedWord = encodeURIComponent(word);
                const wiktionaryUrl = `https://ru.wiktionary.org/wiki/${encodedWord}`;
                
                let htmlContent = `
                    <p class="definition-item">Nh·∫•p v√†o ƒë√¢y ƒë·ªÉ xem chi ti·∫øt nghƒ©a c·ªßa t·ª´ "${word}" tr√™n:</p>
                    <a href="${wiktionaryUrl}" target="_blank" class="text-blue-600 hover:underline font-semibold text-lg">ru.wiktionary.org/wiki</a>
                    <p class="text-sm text-gray-500 mt-2">Trang web s·∫Ω m·ªü trong m·ªôt tab m·ªõi.</p>
                `;
                
                wikiDefinitionContent.innerHTML = htmlContent;
                window.open(wiktionaryUrl, '_blank'); // Open the tab immediately

            } catch (error) {
                console.error(`L·ªói khi t·∫°o li√™n k·∫øt tra c·ª©u t·ª´ "${word}" tr√™n ru.wiktionary.org:`, error);
                wikiDefinitionErrorMessage.textContent = `Kh√¥ng th·ªÉ m·ªü li√™n k·∫øt tra c·ª©u cho t·ª´ "${word}" tr√™n ru.wiktionary.org: ${error.message}. Vui l√≤ng ki·ªÉm tra c√†i ƒë·∫∑t ch·∫∑n pop-up.`;
                wikiDefinitionErrorMessage.classList.remove('hidden');
                definedWikiWord.textContent = `L·ªói tra c·ª©u t·ª´ "${word}"`;
                wikiDefinitionContent.innerHTML = '';
            } finally {
                // No loading spinner to hide here, as it was hidden at the start.
            }
        }

        /**
         * Tra c·ª©u ph√°t √¢m c·ªßa m·ªôt t·ª´ ƒë√£ cho b·∫±ng c√°ch m·ªü li√™n k·∫øt ƒë·∫øn youglish.com.
         * @param {string} word T·ª´ c·∫ßn tra c·ª©u.
         */
        async function lookupYouglish(word) {
            definedYouglishWord.textContent = `ƒêang m·ªü YouGlish cho: "${word}"`;
            youglishContent.innerHTML = '';
            youglishErrorMessage.textContent = '';
            youglishErrorMessage.classList.add('hidden');
            youglishOutput.classList.remove('hidden');
            youglishLoadingSpinner.classList.add('hidden'); // Action is instant, hide spinner

            try {
                // Encode the word for URL to handle special characters correctly
                const encodedWord = encodeURIComponent(word);
                const youglishUrl = `https://youglish.com/pronounce/${encodedWord}/russian`;
                
                let htmlContent = `
                    <p class="definition-item">Nh·∫•p v√†o ƒë√¢y ƒë·ªÉ xem video ph√°t √¢m c·ªßa t·ª´ "${word}" tr√™n:</p>
                    <a href="${youglishUrl}" target="_blank" class="text-blue-600 hover:underline font-semibold text-lg">youglish.com</a>
                    <p class="text-sm text-gray-500 mt-2">Trang web s·∫Ω m·ªü trong m·ªôt tab m·ªõi.</p>
                `;
                
                youglishContent.innerHTML = htmlContent;
                window.open(youglishUrl, '_blank'); // Open the tab immediately

            } catch (error) {
                console.error(`L·ªói khi t·∫°o li√™n k·∫øt tra c·ª©u t·ª´ "${word}" tr√™n youglish.com:`, error);
                youglishErrorMessage.textContent = `Kh√¥ng th·ªÉ m·ªü li√™n k·∫øt tra c·ª©u cho t·ª´ "${word}" tr√™n youglish.com: ${error.message}. Vui l√≤ng ki·ªÉm tra c√†i ƒë·∫∑t ch·∫∑n pop-up.`;
                youglishErrorMessage.classList.remove('hidden');
                definedYouglishWord.textContent = `L·ªói tra c·ª©u t·ª´ "${word}"`;
                youglishContent.innerHTML = '';
            } finally {
                // No loading spinner to hide here, as it was hidden at the start.
            }
        }

        /**
         * X·ª≠ l√Ω t·∫°o t·ª´ v·ª±ng theo ch·ªß ƒë·ªÅ.
         */
        generateVocabularyButton.addEventListener('click', async () => {
            const topic = topicInput.value.trim();
            vocabularyList.innerHTML = '';
            vocabularyErrorMessage.textContent = '';
            vocabularyErrorMessage.classList.add('hidden');
            vocabularyOutput.classList.add('hidden');

            if (!topic) {
                vocabularyErrorMessage.textContent = 'Vui l√≤ng nh·∫≠p m·ªôt ch·ªß ƒë·ªÅ ƒë·ªÉ t·∫°o t·ª´ v·ª±ng.';
                vocabularyErrorMessage.classList.remove('hidden');
                vocabularyOutput.classList.remove('hidden');
                return;
            }

            vocabularyButtonText.textContent = 'ƒêang t·∫°o...';
            vocabularyLoadingSpinner.classList.remove('hidden');
            generateVocabularyButton.disabled = true;
            generateVocabularyButton.classList.add('opacity-70', 'cursor-not-allowed');

            try {
                const vocabularyPrompt = `Generate a list of 10 common Russian vocabulary words related to the topic "${topic}". For each word, provide its Vietnamese translation.
                Format the response as a JSON array of objects, where each object has "russianWord" (string) and "vietnameseTranslation" (string) keys.`;
                
                const generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "russianWord": { "type": "STRING" },
                                "vietnameseTranslation": { "type": "STRING" }
                            },
                            required: ["russianWord", "vietnameseTranslation"]
                        }
                    }
                };

                const vocabularyData = await callGeminiAPI(vocabularyPrompt, generationConfig);

                if (vocabularyData && vocabularyData.length > 0) {
                    vocabularyData.forEach(item => {
                        const listItem = document.createElement('li');
                        listItem.textContent = `${item.russianWord}: ${item.vietnameseTranslation}`;
                        vocabularyList.appendChild(listItem);
                    });
                    vocabularyOutput.classList.remove('hidden');
                } else {
                    vocabularyErrorMessage.textContent = 'Kh√¥ng th·ªÉ t·∫°o t·ª´ v·ª±ng cho ch·ªß ƒë·ªÅ n√†y. Vui l√≤ng th·ª≠ l·∫°i.';
                    vocabularyErrorMessage.classList.remove('hidden');
                    vocabularyOutput.classList.remove('hidden');
                }

            } catch (error) {
                console.error('L·ªói khi t·∫°o t·ª´ v·ª±ng:', error);
                vocabularyErrorMessage.textContent = `ƒê√£ x·∫£y ra l·ªói khi t·∫°o t·ª´ v·ª±ng: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.`;
                vocabularyErrorMessage.classList.remove('hidden');
                vocabularyOutput.classList.remove('hidden');
            } finally {
                vocabularyButtonText.textContent = 'T·∫°o t·ª´ v·ª±ng';
                vocabularyLoadingSpinner.classList.add('hidden');
                generateVocabularyButton.disabled = false;
                generateVocabularyButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }
        });

        /**
         * X·ª≠ l√Ω t·∫°o c√¢u m·∫´u theo ch·ªß ƒë·ªÅ t·ª´ v·ª±ng.
         */
        generateSentenceButton.addEventListener('click', async () => {
            const topic = sentenceTopicInput.value.trim();
            sentenceList.innerHTML = '';
            sentenceErrorMessage.textContent = '';
            sentenceErrorMessage.classList.add('hidden');
            sentenceOutput.classList.add('hidden');

            if (!topic) {
                sentenceErrorMessage.textContent = 'Vui l√≤ng nh·∫≠p m·ªôt ch·ªß ƒë·ªÅ ƒë·ªÉ t·∫°o c√¢u m·∫´u.';
                sentenceErrorMessage.classList.remove('hidden');
                sentenceOutput.classList.remove('hidden');
                return;
            }

            sentenceButtonText.textContent = 'ƒêang t·∫°o...';
            sentenceLoadingSpinner.classList.remove('hidden');
            generateSentenceButton.disabled = true;
            generateSentenceButton.classList.add('opacity-70', 'cursor-not-allowed');

            try {
                const sentencePrompt = `Generate 3-5 common Russian sentences related to the topic "${topic}". For each sentence, provide its Vietnamese translation.
                Format the response as a JSON array of objects, where each object has "russianSentence" (string) and "vietnameseTranslation" (string) keys.`;
                
                const generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "russianSentence": { "type": "STRING" },
                                "vietnameseTranslation": { "type": "STRING" }
                            },
                            required: ["russianSentence", "vietnameseTranslation"]
                        }
                    }
                };

                const sentenceData = await callGeminiAPI(sentencePrompt, generationConfig);

                if (sentenceData && sentenceData.length > 0) {
                    sentenceData.forEach(item => {
                        const listItem = document.createElement('li');
                        listItem.innerHTML = `<strong>${item.russianSentence}</strong>: ${item.vietnameseTranslation}`;
                        sentenceList.appendChild(listItem);
                    });
                    sentenceOutput.classList.remove('hidden');
                } else {
                    sentenceErrorMessage.textContent = 'Kh√¥ng th·ªÉ t·∫°o c√¢u m·∫´u cho ch·ªß ƒë·ªÅ n√†y. Vui l√≤ng th·ª≠ l·∫°i.';
                    sentenceErrorMessage.classList.remove('hidden');
                    sentenceOutput.classList.remove('hidden');
                }

            } catch (error) {
                console.error('L·ªói khi t·∫°o c√¢u m·∫´u:', error);
                sentenceErrorMessage.textContent = `ƒê√£ x·∫£y ra l·ªói khi t·∫°o c√¢u m·∫´u: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.`;
                sentenceErrorMessage.classList.remove('hidden');
                sentenceOutput.classList.remove('hidden');
            } finally {
                sentenceButtonText.textContent = 'T·∫°o c√¢u m·∫´u';
                sentenceLoadingSpinner.classList.add('hidden');
                generateSentenceButton.disabled = false;
                generateSentenceButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }
        });
    </script>
</body>
</html>
